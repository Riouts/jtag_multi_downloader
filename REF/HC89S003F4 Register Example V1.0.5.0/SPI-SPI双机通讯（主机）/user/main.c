/**
*   ************************************************************************************
*								上海芯圣电子股份有限公司
*								    www.holychip.cn
*	************************************************************************************
*	@Examle Version		V1.0.5.0
*	@Demo 	Version		V1.0.4.0
*	@Date				2019.12.27
*	************************************************************************************
*									 模块性能介绍
*	1、全双工，三/四线同步传输
*	2、主从机操作
*	3、4级可编程主时钟频率
*	4、极性相位可编程的串行时钟
*	5、可选择数据传输方向
*	6、写冲突及接收溢出标志
*	7、带MCU中断的主模式模式冲突检测
*	8、带MCU中断的传输结束标志
*	************************************************************************************
*									 应用注意事项
*	1、SSIG=0&CPHA=0时，数据在SS为低被驱动；CPHA=1时，数据在SCK的前时钟沿驱动
*	2、接收为双BUFF，接收溢出发生在第二个数据传送完成前仍未清除之前接收数据产生的SPIF标
*	   志，故每次准备接收下一个数据前必须先清除SPIF，否则RXOV将置1，RXOV置1不会影响SPI接
*	   收
*	************************************************************************************
*  								       客户服务
*	感谢您使用我们的单片机，若发现错误或对函数的使用存在疑问。请添加上海芯圣电子官方QQ群
*	****************************技术支持群：201030494***********************************
*   ************************************************************************************
**/

#define ALLOCATE_EXTERN
#include "HC89S003F4.h"

unsigned char SPI_WriteReadData(unsigned char fuc_Data);  //SPI读写数据
void Delay_ms(unsigned int fui_i);		                    //延时函数

/***************************************************************************************
  * @实现效果	  主机一直向从机发送数据0xAA，从机将接收的数据通过串口发送至上位机
  * @操作步骤   两个MCU相同IO连接，P0_0-->P0_0 P0_1-->P0_1 P2_0-->P2_0        
***************************************************************************************/
void main()
{
/************************************系统初始化****************************************/
	WDTCCR = 0x00;						     //关闭看门狗
		                             //本例程为方便测试关闭看门狗，实际使用中，建议客户打开看门狗，详见WDT复位例程
	CLKSWR = 0x51;						     //选择内部高频RC为系统时钟，内部高频RC 2分频，Fosc=16MHz
	CLKDIV = 0x01;						     //Fosc 1分频得到Fcpu，Fcpu=16MHz 
/************************************SPI初始化*****************************************/
  P0M0 = P0M0&0x0F|0x40;         //P01带SMT输入
  P0M0 = P0M0&0xF0|0x08;         //P00推挽输出
  P2M0 = P2M0&0xF0|0x08;         //P20推挽输出	
	MISO_MAP = 0x01;	             //SPI_MISO 映射到P01口
	MOSI_MAP = 0x00;	             //SPI_MOSI 映射到P00口
	SCK_MAP = 0x20;		             //SPI_SCK  映射到P20口
	SPDAT = 0x00;                  //数据寄存器写0
	SPSTAT = 0x00;                 //状态寄存器清0           
	SPCTL = 0xD7;                  //主机模式，时钟128分频
   
	while(1)
	{
		SPI_WriteReadData(0xAA);     //发送数据0xAA
		Delay_ms(500);
	}   
}

/**
  * @说明  	SPI写读函数
  *	@参数	  fuc_Data ：SPI读写数据
  * @返回值 SPDAT : SPI读取数据
  * @注		  无
  */
unsigned char SPI_WriteReadData(unsigned char fuc_Data)
{
	SPSTAT = 0xC0;
	SPDAT = fuc_Data;
	while(!(SPSTAT&0x80));
	SPSTAT = 0xC0;
	return SPDAT;
}

/**
  * @说明  	延时函数
  * @参数  	fui_i : 延时时间
  * @返回值 无
  * @注 	  Fcpu = 16MHz，fui_i = 1时，延时时间约为1Ms
  */
void Delay_ms(unsigned int fui_i)
{
	unsigned int fui_j;
	for(;fui_i > 0;fui_i --)
	for(fui_j = 1596;fui_j > 0;fui_j --);
}

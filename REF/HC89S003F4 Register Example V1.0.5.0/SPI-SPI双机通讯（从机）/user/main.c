/**
*   ************************************************************************************
*								上海芯圣电子股份有限公司
*								    www.holychip.cn
*	************************************************************************************
*	@Examle Version		V1.0.5.0
*	@Demo 	Version		V1.0.4.0
*	@Date				2019.12.27
*	************************************************************************************
*									 模块性能介绍
*	1、全双工，三/四线同步传输
*	2、主从机操作
*	3、4级可编程主时钟频率
*	4、极性相位可编程的串行时钟
*	5、可选择数据传输方向
*	6、写冲突及接收溢出标志
*	7、带MCU中断的主模式模式冲突检测
*	8、带MCU中断的传输结束标志
*	************************************************************************************
*									 应用注意事项
*	1、SSIG=0&CPHA=0时，数据在SS为低被驱动；CPHA=1时，数据在SCK的前时钟沿驱动
*	2、接收为双BUFF，接收溢出发生在第二个数据传送完成前仍未清除之前接收数据产生的SPIF标
*	   志，故每次准备接收下一个数据前必须先清除SPIF，否则RXOV将置1，RXOV置1不会影响SPI接
*	   收
*	************************************************************************************
*  								       客户服务
*	感谢您使用我们的单片机，若发现错误或对函数的使用存在疑问。请添加上海芯圣电子官方QQ群
*	****************************技术支持群：201030494***********************************
*   ************************************************************************************
**/

#define ALLOCATE_EXTERN
#include "HC89S003F4.h"

unsigned char guc_ReceiveValue = 0;		//SPI接收数据
unsigned char SPI_ReadData();			    //SPI读数据

/***************************************************************************************
  * @实现效果	 主机一直向从机发送数据0xAA，从机将接收的数据通过串口发送至上位机
  * @操作步骤  两个MCU相同IO连接，P0_0-->P0_0 P0_1-->P0_1 P2_0-->P2_0        
***************************************************************************************/
void main()
{
/************************************系统初始化****************************************/
	WDTCCR = 0x00;						            //关闭看门狗
		                                    //本例程为方便测试关闭看门狗，实际使用中，建议客户打开看门狗，详见WDT复位例程
	CLKSWR = 0x51;						            //选择内部高频RC为系统时钟，内部高频RC 2分频，Fosc=16MHz
	CLKDIV = 0x01;					            	//Fosc 1分频得到Fcpu，Fcpu=16MHz 
/**********************************相关配置初始化**************************************/
	P2M0 = P2M0&0x0F|0x80;			         	//P21设置为推挽输出
	P0M1 = P0M1&0x0F|0x20;				        //P03设置为上拉输入
	TXD_MAP = 0x21;						            //TXD映射P21
	RXD_MAP = 0x03;					            	//RXD映射P03		
	T4CON = 0x06;						              //T4工作模式：UART1波特率发生器
  TH4 = 0xFF; 
	TL4 = 0x98;						  	            //波特率9600
	SCON2 = 0x02;						              //8位UART，波特率可变
	SCON = 0x10;					  	            //允许串行接收
	IE |= 0x10;							              //使能串口中断
/************************************SPI初始化*****************************************/
  P0M0 = P0M0&0x0F|0x80;                //P01推挽输出
  P0M0 = P0M0&0xF0|0x04;                //P00带SMT输入
  P2M0 = P2M0&0xF0|0x04;                //P20带SMT输入
	MISO_MAP = 0x01;	            	      //SPI_MISO 映射到P01口
	MOSI_MAP = 0x00;	            	      //SPI_MOSI 映射到P00口
	SCK_MAP = 0x20;		                    //SPI_SCK  映射到P20口
	SPDAT = 0x00;                         //数据寄存器写0
	SPSTAT = 0x00;                        //状态寄存器清0           
	SPCTL = 0xC7;                         //从机模式，时钟128分频
  IE1 |= 0x01;					              	//打开SPI中断
  EA = 1;    
 
	while(1)
    {
			EA = 0;    
			SBUF = 0xBB;					            //发送8位串口数据
			while(!(SCON & 0x02));
			SCON &=~ 0x02;					          //清除发送中断标志位
			SBUF = guc_ReceiveValue;		      //发送8位串口数据
			while(!(SCON & 0x02));
			SCON &=~ 0x02;					          //清除发送中断标志位
			EA = 1;   
    }   
}

/***************************************************************************************
  * @说明  	SPI中断服务函数
  *	@参数	  无
  * @返回值 无
  * @注		  无
***************************************************************************************/
void SPI_Rpt(void) interrupt SPI_VECTOR
{
	SPSTAT |= 0x80;						            //清除中断标志位		
	guc_ReceiveValue = SPI_ReadData();	  //读取数据
}

/**
  * @说明  	SPI读函数
  *	@参数	  无
  * @返回值 SPDAT : SPI读取数据
  * @注		  无
  */
unsigned char SPI_ReadData()
{
	return SPDAT;						              //返回数据
}
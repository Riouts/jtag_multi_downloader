/**
*   ************************************************************************************
*								上海芯圣电子股份有限公司
*								    www.holychip.cn
*	************************************************************************************
*	@Examle Version		V1.0.5.0
*	@Demo 	Version		V1.0.4.0
*	@Date				2019.12.27
*	************************************************************************************
*									 模块性能介绍
*	1、Flash擦写次数10万次以上
*	2、扇区擦除时间约5ms，且擦除时不响应任何中断，但会置相关标志位，擦除完成后响应
*	3、可设置应用程序读保护，应用程序写保护（以4K字节为保护单位）
*	4、可以设置仿真器扇区读保护，扇区写保护（以4K字节为保护单位）
*	5、设置保护后无法擦写程序，读取的数据全为零
* 6、每一颗MCU在出厂时会固化一个CHIP_ID，一共8个字节，一颗芯片一个ID，不会重复
*	************************************************************************************
*									 应用注意事项
*	1、Fcpu需要配置为1-16MHz之间的正整数，且Flash擦写之前需要配置FREQ_CLK寄存器，该寄存器
*	   值即为当前CPU时钟频率。
*	2、扇区擦除写入过程中不能被打断
*	3、数据存放地址需要在程序存放地址之后
*	4、第二复位向量使能时，无法在仿真环境下查看code区数据
* 5、Flsah操作最低电压限制为2.0V，所以建议进行Flash操作前进行电压检测或者打开BOR，BOR电
*      压建议设置为2.4V及2.4V以上
*	6、建议在进行Flash擦写操作前关闭中断，擦写完成后再打开中断
*	************************************************************************************
*  								       客户服务
*	感谢您使用我们的单片机，若发现错误或对函数的使用存在疑问。请添加上海芯圣电子官方QQ群
*	****************************技术支持群：201030494***********************************
*   ************************************************************************************
**/

#define ALLOCATE_EXTERN
#include "HC89S003F4.h"
#include "string.h"

void Flash_ReadArr(unsigned int fui_Address,unsigned char fuc_Length,unsigned char *fucp_SaveArr);

unsigned char guc_Read_a[8] = {0x00};			     //用于存放读取的数据
unsigned char guc_CompareBuf_a[] = "Read Chip ID\r";
unsigned char guc_CompareFlag = 1;             //内存比较标志位
unsigned char guc_Uartflag = 0;				       	 //发送标志位
unsigned char guc_Uartcnt = 0;					       //发送计数
unsigned char guc_Uartbuf_a[13] = {0x00};		   //缓存数组
unsigned char guc_i;					                 //发送数据计数	

/***************************************************************************************
  * @实现效果	  读取芯片的CHIP ID。
  * @操作步骤   接上RXD TXD短路帽，通过串口工具向单片机发送字符串Read Chip ID\r，返回MCU
  *             的CHIP ID。
***************************************************************************************/
void main()
{
/************************************系统初始化****************************************/
	WDTCCR = 0x00;						    //关闭看门狗
		                            //本例程为方便测试关闭看门狗，实际使用中，建议客户打开看门狗，详见WDT复位例程
	CLKSWR = 0x51;						    //选择内部高频RC为系统时钟，内部高频RC 2分频，Fosc=16MHz
	CLKDIV = 0x01;						    //Fosc 1分频得到Fcpu，Fcpu=16MHz 
/**********************************相关配置初始化**************************************/
	P2M0 = P2M0&0x0F|0x80;				//P21设置为推挽输出
	P0M1 = P0M1&0x0F|0x20;				//P03设置为上拉输出
	TXD_MAP = 0x21;						    //TXD映射P21
	RXD_MAP = 0x03;						    //RXD映射P03		
	T4CON = 0x06;						      //T4工作模式：UART1波特率发生器
  TH4 = 0xFF;
	TL4 = 0x98;							      //波特率9600
	SCON2 = 0x02;						      //8位UART，波特率可变
	SCON = 0x10;						      //允许串行接收
	IE |= 0x10;							      //使能串口中断
/**********************************Flash配置初始化*************************************/
  INSCON |= 0x10;                       //数据指针指到OPTION区
	Flash_ReadArr(0x0100,8,guc_Read_a);	  //读取CHIPID
  INSCON &=~ 0x10;                      //数据指针指回Flash区
	EA = 1;								                //使能总中断
	while(1) 
	{
		if(guc_Uartflag)
		{
			IE &=~ 0x10;				                //失能UART1中断
			guc_CompareFlag = memcmp(guc_Uartbuf_a,guc_CompareBuf_a,13);//比较接收数据是否正确
			if(guc_CompareFlag == 0)
			{
				for(guc_i= 0;guc_i<8;guc_i++)
				{
					SBUF = guc_Read_a[guc_i];     //发送8位串口数据
					while(!(SCON & 0x02));
					SCON &=~ 0x02;			          //清除发送中断标志位
				}             
			}
			IE |= 0x10;					                //UART1中断使能
			guc_Uartflag = 0;
			guc_Uartcnt = 0;
			SCON |= 0x10;				                //UART1接收使能
     }
	}
}

/***************************************************************************************
  * @说明  	UART1中断服务函数
  *	@参数	  无
  * @返回值 无
  * @注		  无
***************************************************************************************/
void UART1_Rpt(void) interrupt UART1_VECTOR
{
	if(SCON&0x01)							              //判断接收中断标志位
	{
		guc_Uartbuf_a[guc_Uartcnt++] = SBUF;  //转存8位串口接收数据
		if(guc_Uartcnt >= 13)
		{
			SCON &=~ 0x10;					            //失能UART1接收
			guc_Uartflag = 1;
		}
		SCON &=~ 0x01;					            	//清除接收中断标志位
	}
}

/**
  * @说明  	从FLASH里面读取任意长度的数据
  * @参数  	fui_Address ：FLASH起始地址
  *			    取值范围：0x0000-0x3FFF
  *	@参数	  fuc_Length ： 读取数据长度
  *			    取值范围：0x00-0xFF
  *	@参数	 *fucp_SaveArr：读取数据存放的区域首地址
  * @返回值 无
  * @注		  无
  */
void Flash_ReadArr(unsigned int fui_Address,unsigned char fuc_Length,unsigned char *fucp_SaveArr)
{
	while(fuc_Length--)
	*(fucp_SaveArr++)=*((unsigned char code *)(fui_Address++));//读取数据
}
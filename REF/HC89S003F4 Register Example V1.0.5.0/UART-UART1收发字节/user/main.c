/**
*   ************************************************************************************
*								上海芯圣电子股份有限公司
*								    www.holychip.cn
*	************************************************************************************
*	@Examle Version		V1.0.5.0
*	@Demo 	Version		V1.0.4.0
*	@Date				2019.12.27
*	************************************************************************************
*									 模块性能介绍
* 1、UART1有4种工作方式，在四种方式中，任何将SBUF作为目标寄存器的写操作都会启动发送
*	   方式0：同步半双工通讯
*	   方式 1：8位UART，可变波特率，异步全双工
*	   方式 2：9位UART，固定波特率，异步全双工
*	   方式 3：9位UART，可变波特率，异步全双工
*	************************************************************************************
*									 应用注意事项
*	1、使用串口时，需要Fosc和Fcpu时钟一致，如时钟不一致，请勿操作发送冲突标志位（TXCOL），
*	   否则会造成串口功能异常
*	************************************************************************************
*  								       客户服务
*	感谢您使用我们的单片机，若发现错误或对函数的使用存在疑问。请添加上海芯圣电子官方QQ群
*	****************************技术支持群：201030494***********************************
*   ************************************************************************************
**/

#define ALLOCATE_EXTERN
#include "HC89S003F4.h"

unsigned char guc_Uartflag = 0;			  //UART判断标志位
unsigned char guc_Uartcnt = 0;		    //UART计数使用
unsigned char guc_Uartbuf_a[5] = {0};	//用于存放接收收据
unsigned char guc_i;					        //发送数据计数	

/***************************************************************************************
  * @实现效果	UART1接收到上位机发送的5个8位数据后，把接接收的5个数据再次发送给上位机
  * @操作步骤 接上TXD，RXD短路帽，然后通过上位机软件发送5个8位数据
  * @注意事项	波特率9600，8位数据，无校验位		
***************************************************************************************/
void main()
{
/************************************系统初始化****************************************/
	WDTCCR = 0x00;						          //关闭看门狗
		                                  //本例程为方便测试关闭看门狗，实际使用中，建议客户打开看门狗，详见WDT复位例程
	CLKSWR = 0x51;					           	//选择内部高频RC为系统时钟，内部高频RC 2分频，Fosc=16MHz
	CLKDIV = 0x01;						          //Fosc 1分频得到Fcpu，Fcpu=16MHz 
/**********************************UART配置初始化**************************************/
	P2M0 = P2M0&0x0F|0x80;				      //P21设置为推挽输出
	P0M1 = P0M1&0x0F|0x20;				      //P03设置为上拉输入
	TXD_MAP = 0x21;						          //TXD映射P21
	RXD_MAP = 0x03;						          //RXD映射P03		
	T4CON = 0x06;						            //T4工作模式：UART1波特率发生器
	
	//波特率计算
	//波特率 = 1/16 * (T4时钟源频率 / 定时器4预分频比) / (65536 - 0xFF98)
	//       = 1/16 * ((16000000 / 1) / 104)
	//		 = 9615.38(误差0.16%)

	//波特率9600
	//反推初值 = (65536 - ((T4时钟源频率 / 定时器4预分频比) * (1 / 16)) / 波特率)
	//		   = (65536 - (16000000 * (1 / 16) / 9600))
	//		   = (65536 - 104.167)
	//         = FF98
	
  TH4 = 0xFF;
	TL4 = 0x98;							             //波特率9600
	SCON2 = 0x02;						             //8位UART，波特率可变
	SCON = 0x10;					               //允许串行接收
	IE |= 0X10;							             //使能串口中断
	EA = 1;							              	 //使能总中断
    
	while(1)
	{
		if(guc_Uartflag)
		{
			IE &=~ 0x10;				             //失能UART1中断
			for(guc_i= 0;guc_i<guc_Uartcnt;guc_i++)
			{
				SBUF = guc_Uartbuf_a[guc_i];   //发送8位串口数据
				while(!(SCON & 0x02));
				SCON &=~ 0x02;			           //清除发送中断标志位
			}
			IE |= 0x10;					             //UART1中断使能
			guc_Uartflag = 0;
			guc_Uartcnt = 0; 
			SCON |= 0x10;				             //UART1接收使能
		}	
	}
}

/***************************************************************************************
  * @说明  	UART1中断服务函数
  *	@参数	  无
  * @返回值 无
  * @注		  无
***************************************************************************************/
void UART1_Rpt(void) interrupt UART1_VECTOR
{
	if(SCON & 0x01)						            //判断接收中断标志位
	{
		guc_Uartbuf_a[guc_Uartcnt++] = SBUF;//转存8位串口接收数据
		if(guc_Uartcnt >= 5)
		{
			SCON &=~ 0x10;				            //失能UART1接收
			guc_Uartflag = 1;
		}
		  SCON &=~ 0x01;					          //清除接收中断标志位
	}									
}
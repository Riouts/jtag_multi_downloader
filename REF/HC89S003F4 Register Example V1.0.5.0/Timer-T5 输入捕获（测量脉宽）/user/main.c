/**
* ************************************************************************************
*								上海芯圣电子股份有限公司
*								    www.holychip.cn
*	************************************************************************************
*	@Examle Version		V1.0.5.0
*	@Demo 	Version		V1.0.4.0
*	@Date				2019.12.27
*	************************************************************************************
*									    模块性能介绍
* 1、定时器5有三种工作模式
*	   工作模式1：16位自动重载定时器
*	   工作模式2；串口波特率发生器
*	   工作模式3：16位上/下沿捕获
*	************************************************************************************
*									    应用注意事项
*	1、需要配置 I/O 章节里面的复用端口T5_MAP寄存器，将timer5配置到任意的IO上面并且对应
*	   I/O必须设为输入模式 
*	2、当捕获低频内部RC或RXD引脚时，也需要使能EXEN5，同时还要配置上升沿捕获或下降沿捕获
*	************************************************************************************
*  								       客户服务
*	 感谢您使用我们的单片机，若发现错误或对函数的使用存在疑问。请添加上海芯圣电子官方QQ
*	****************************技术支持QQ：800181626**********************************
* ************************************************************************************
**/

#define ALLOCATE_EXTERN
#include "HC89S003F4.h"
#include "stdio.h"
 
unsigned int gui_T5Value;             //T5捕获获取值
unsigned char guc_WaitFallEdge=0;     //捕获高低电平标志位
void Delay_ms(unsigned int fui_i);    //延时函数
/***************************************************************************************
  * @实现效果	  T5设置为捕获模式，对P01口的高低电平脉宽进行捕获，从串口输出
  * @操作步骤   将端口 P01->P00 连接，TXD为 P2_1
***************************************************************************************/
void main() 
{
/************************************系统初始化****************************************/
	WDTCCR = 0x00;						          //关闭看门狗
		                                  //本例程为方便测试关闭看门狗，实际使用中，建议客户打开看门狗，详见WDT复位例程
	CLKSWR = 0x51;						          //选择内部高频RC为系统时钟，内部高频RC 2分频，Fosc=16MHz
	CLKDIV = 0x01;						          //Fosc 1分频得到Fcpu，Fcpu=16MHz 
/**********************************相关配置初始化**************************************/
	P0M0 = P0M0&0xF0|0x08;              //P00设置为推挽输出	
/**********************************UART配置初始化**************************************/
	P2M0 = P2M0&0x0F|0x80;				      //P21设置为推挽输出
	TXD_MAP = 0x21;						          //TXD映射P21		
	T4CON = 0x06;						            //T4工作模式：UART1波特率发生器
	//波特率计算
	//波特率 = 1/16 * (T4时钟源频率 / 定时器4预分频比) / (65536 - 0xFF98)
	//       = 1/16 * ((16000000 / 1) / 104)
	//		 = 9615.38(误差0.16%)

	//波特率9600
	//反推初值 = (65536 - ((T4时钟源频率 / 定时器4预分频比) * (1 / 16)) / 波特率)
	//		   = (65536 - (16000000 * (1 / 16) / 9600))
	//		   = (65536 - 104.167)
	//         = FF98
  TH4 = 0xFF;
	TL4 = 0x98;							            //波特率9600
	SCON2 = 0x02;						            //8位UART，波特率可变
/**********************************TIM5配置初始化**************************************/
  P0M0 = P0M0&0x0F|0x20;              //P01设置为上拉输入
	T5_MAP = 0x01;						          //T5捕获口映射P01端口
	T5CON = 0x1F;						            //时钟8分频，16位下降沿捕获
	T5CON1 = 0x00;						          //T5捕获类型选择T5脚的变化沿
	TH5 = 0x00;
	TL5 = 0x00;							            //计数值清0
	IE1 |= 0x10;					      	      //打开T5中断
	EA = 1;
	while(1)
	{  
		P0_0 = 0;
	  Delay_ms(1);
		P0_0 = 1;
		Delay_ms(2);
	}
}

/***************************************************************************************
  * @说明  	T5中断服务函数
  *	@参数	  无
  * @返回值 无
  * @注		  无
***************************************************************************************/
void TIMER5_Rpt(void) interrupt T5_VECTOR
{
	if(T5CON&0x40)                       //是否为外部事件
	{
		gui_T5Value = RCAP5/2;			       //读取获取的数据，单位转换成 1 us
		T5CON &=~ 0x40;						         //清除引脚外部输入事件发生标志位   	
		if(guc_WaitFallEdge==0)   
		{	
			printf("\n低电平脉宽：%d 微秒\n",gui_T5Value);
			TH5 = 0x00;
			TL5 = 0x00;	
			T5CON = 0x1F;						          //时钟8分频，16位下降沿捕获		
			T5CON1 = 0x00;						        //T5捕获类型选择T5脚的变化沿
			guc_WaitFallEdge = 1;
		}
		else
		{
			printf("\n高电平脉宽：%d 微秒\n",gui_T5Value);			
			TH5 = 0x00;
			TL5 = 0x00;	
			T5CON = 0x1B;						           //时钟8分频，16位上升沿捕获
			T5CON1 = 0x00;						         //T5捕获类型选择T5脚的变化沿
			guc_WaitFallEdge = 0;
		}
	}
	if(T5CON&0x80)
	{
		T5CON &=~ 0x80;						           //清除T5中断标志位
	}
}

/**
  * @说明  	重定义putc函数，这样可以使用printf函数从串口1打印输出
  * @参数  	无
  * @返回值 无
  * @注 	  无
  */
char putchar(char guc_Uartbuf)
{
			SBUF = guc_Uartbuf;               //发送8位串口数据
			while(!(SCON & 0x02));
			SCON &=~ 0x02;			              //清除发送中断标志位
      return guc_Uartbuf;
}
/**
  * @说明  	延时函数
  * @参数  	fui_i : 延时时间
  * @返回值 无
  * @注 	  Fcpu = 16MHz，fui_i = 1时，延时时间约为1Ms
  */
void Delay_ms(unsigned int fui_i)
{
	unsigned int fui_j;
	for(;fui_i > 0;fui_i --)
	for(fui_j = 1596;fui_j > 0;fui_j --);
}

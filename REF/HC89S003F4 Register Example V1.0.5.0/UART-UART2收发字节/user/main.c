/**
*   ************************************************************************************
*								上海芯圣电子股份有限公司
*								    www.holychip.cn
*	************************************************************************************
*	@Examle Version		V1.0.5.0
*	@Demo 	Version		V1.0.4.0
*	@Date				2019.12.27
*	************************************************************************************
*									 模块性能介绍
* 1、UART2有4种工作方式，在四种方式中，任何将SBUF作为目标寄存器的写操作都会启动发送
*	   方式 1：8位UART，可变波特率，异步全双工
*	   方式 2：9位UART，可变波特率，异步全双工
*	************************************************************************************
*									   注意事项
*	1、波特率使用T5重载捕获寄存器
*	2、使用串口时，需要Fosc和Fcpu时钟一致，如时钟不一致，请勿操作发送冲突标志位（TXCOL），
*	   否则会造成串口功能异常
*   ************************************************************************************
*  								       客户服务
*	感谢您使用我们的单片机，若发现错误或对函数的使用存在疑问。请添加上海芯圣电子官方QQ群
*	****************************技术支持群：201030494***********************************
*   ************************************************************************************
**/

#define ALLOCATE_EXTERN
#include "HC89S003F4.h"

unsigned char guc_Uartflag = 0;			  //UART判断标志位
unsigned char guc_Uartcnt = 0;		    //UART计数使用
unsigned char guc_Uartbuf_a[5] = {0};	//用于存放接收收据
unsigned char guc_i;					        //发送数据计数	

/***************************************************************************************
  * @实现效果	UART2接收到上位机发送的5个8位数据后，把接接收的5个数据再次发送给上位机
  * @操作步骤 接上TXD，RXD短路帽，然后通过上位机软件发送5个8位数据
  * @注意		  波特率9600，8位数据，无校验位		
***************************************************************************************/
void main()
{
	WDTCCR = 0x00;						    //关闭看门狗
		                            //本例程为方便测试关闭看门狗，实际使用中，建议客户打开看门狗，详见WDT复位例程
	CLKSWR = 0x51;						    //选择内部高频RC为系统时钟，内部高频RC 2分频，Fosc=16MHz
	CLKDIV = 0x01;						    //Fosc 1分频得到Fcpu，Fcpu=16MHz 
/**********************************UART配置初始化**************************************/
	P2M0 = P2M0&0x0F|0x80;				//P21设置为推挽输出
	P0M1 = P0M1&0x0F|0x20;				//P03设置为上拉输入
	TXD2_MAP = 0x21;					    //TXD映射P21
	RXD2_MAP = 0x03;					    //RXD映射P03		
	//波特率计算
	//波特率 = 1/16 * (T5时钟源频率 / 定时器5预分频比) / (65536 - 0xFF98)
	//       = 1/16 * ((16000000 / 1) / 104)
	//		   = 9615.38(误差0.16%)

	//波特率9600
	//反推初值 = (65536 - ((T5时钟源频率 / 定时器5预分频比) * (1 / 16)) / 波特率)
	//		     = (65536 - (16000000 * (1 / 16) / 9600))
	//		     = (65536 - 104.167)
	//         = FF98

	RCAP5H = 0xFF;
	RCAP5L = 0x98;
	T5CON = 0x06;						      //T5工作模式：UART2波特率发生器
	S2CON2 = 0x00;						    //8位UART，波特率可变
	S2CON = 0x10;					      	//允许串行接收
	IE |= 0x40;						      	//使能串口中断

	EA = 1;							        	//使能总中断
	while(1)
	{
		if(guc_Uartflag)
		{
			IE &=~ 0x40;				              //失能UART2中断
			for(guc_i=0;guc_i<guc_Uartcnt;guc_i++)
			{
				S2BUF = guc_Uartbuf_a[guc_i];		//发送8位串口数据
				while(!(S2CON & 0x02));
				S2CON &=~ 0x02;			            //清除发送中断标志位
			}
			IE |= 0x40;					              //UART2中断使能
			guc_Uartflag = 0;
			guc_Uartcnt = 0;
			S2CON |= 0x10;;			             	//UART2接收使能
		}
	}
}

/***************************************************************************************
  * @说明  	UART2中断服务函数
  *	@参数	  无
  * @返回值 无
  * @注		  无
***************************************************************************************/
void UART2_Rpt(void) interrupt UART2_VECTOR
{
	if(S2CON&0x01)					              //判断接收中断标志位
	{
		guc_Uartbuf_a[guc_Uartcnt++] = S2BUF;//转存8位串口接收数据
		if(guc_Uartcnt >= 5)
		{
			S2CON &=~ 0x10;				             //失能UART1接收
			guc_Uartflag = 1;
		}
		S2CON &=~ 0x01;				             	//清除接收中断标志位
	}									
}